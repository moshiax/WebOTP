<!DOCTYPE html>
<html lang="en">
  <head>
	<meta charset="UTF-8" />
	<link rel="icon" href="icon.png" type="image/png" />
	<meta name="viewport" content="width=device-width, initial-scale=1.0" />
	<title>WebOTP</title>
	<link rel="manifest" href="manifest.json">
	<link rel="stylesheet" href="styles.css" />
  </head>
  <body>
	<header>
	  <input type="search" id="key-search" placeholder="Search..." oninput="filterKeyCards(this.value)">
	</header>
	<main>
<div id="keysContainer"></div>
<div class="buttonContainer" style="display:none;">
  <button id="addKeyUIBtn" onclick="openModal('addKeyUIModal')">Add Key</button>
  <button class="addMasterKeyBtn" onclick="addMasterKey()">Add master key</button>
  <button id="managesecretKeysBtn" onclick="openManagesecretKeysModal()">My secret keys</button>
  <button id="manageMasterKeysBtn" onclick="openManageMasterModal()">My master keys</button>
  <br/>
  <button id="clearStorageBtn">Clear All Data</button>
  <button id="settingsBtn" onclick="openSettingsModal()">Settings</button>
</div>

	</main>
	<div id="notification" class="notification">
	  <p></p>
	</div>
	<div id="copyModal">
	  <div id="copyModalContent">
		<textarea id="copyTextArea" readonly></textarea>
		<button id="copyButton">Copy</button>
	  </div>
	</div>
	<div id="manageMasterModal" class="modal">
	  <div id="manageMasterModalContent" class="modal-content">
		<span id="closeManageMasterModal" class="close" onclick="closeModal('manageMasterModal');">&times;</span>
		<h2 style="text-align: center;">Master Keys</h2>
		<table id="masterKeysTable">
		  <thead>
			<tr>
			  <th>Master key</th>
			  <th>SHA256</th>
			  <th>Usage Count</th>
			  <th>Actions</th>
			</tr>
		  </thead>
		  <tbody></tbody>
		</table>
		<div style="text-align: center; margin-top: 20px;">
		  <button class="addMasterKeyBtn" onclick="addMasterKey()">Add master key</button>
		  <button id="toggleRevealMasterKeysBtn">Reveal master keys</button>
		</div>
		<div id="masterEncryptionControls" style="text-align: center; margin-top: 10px;"></div>
	  </div>
	</div>
	<div id="addKeyUIModal" class="modal">
	  <div class="modal-content">
		<span id="closeaddKeyUIModal" class="close" onclick="closeModal('addKeyUIModal');">&times;</span>
		<h2 style="text-align: center;">Choose Source</h2>
		<div style="text-align: center;">
		  <button onclick="startCameraScan()">From Camera (QR)</button>
		  <br>
		  <input type="file" id="file-input" accept="image/*" style="display: none;" multiple onchange="handleFileSelection(event)">
		  <button onclick="document.getElementById('file-input').click()">From Gallery (QR)</button>
		  <br>
		  <button onclick="addKeyUI()">From Secret Key (TEXT)</button>
		</div>
	  </div>
	</div>
	<div id="qrScannerModal" class="modal">
	  <div class="modal-content">
		<span class="close" onclick="closeModal('qrScannerModal');">&times;</span>
		<h2>Scan QR Code</h2>
		<video id="video" width="300" height="300" autoplay></video>
		<canvas id="canvas" style="display: none;"></canvas>
		<div style="text-align: center;">
		  <p id="qr-result">Waiting for QR scan...</p>
		</div>
	  </div>
	</div>
	<div id="managesecretKeysModal" class="modal">
	  <div id="managesecretKeysModalContent" class="modal-content">
		<span id="closeManagesecretKeysModal" class="close" onclick="closeModal('managesecretKeysModal');">&times;</span>
		<h2 style="text-align: center;">Secret Keys</h2>
		<table id="secretKeysTable">
		  <thead></thead>
		  <tbody></tbody>
		</table>
	  </div>
	</div>
	<dialog id="customPromptDialog">
	  <form method="dialog">
		<p id="customPromptText"></p>
		<input type="text" id="customPromptInput" autocomplete="off" />
		<div style="text-align: center;">
		  <button type="submit" id="customPromptOk">OK</button>
		  <button type="button" id="customPromptCancel">Cancel</button>
		</div>
	  </form>
	</dialog>
	<div id="settingsModal" class="modal">
	  <div id="settingsModalContent" class="modal-content">
		<span id="closeSettingsModal" class="close" onclick="closeModal('settingsModal');">&times;</span>
		<h2 style="text-align: center;">Settings</h2>
		<div id="settingsContainer"></div>
		<div id="additionalSettings" style="text-align: center; margin-top: 20px;">
		  <div class="buttonContainer">
			<button id="exportTextBtn" onclick="exportData(false)">Export String</button>
			<button id="exportFileBtn" onclick="exportData(true)">Export File</button>
			<button id="importTextBtn" onclick="importData(false)">Import String</button>
			<button id="importFileBtn" onclick="importData(true)">Import File</button>
		  </div>
		</div>
	  </div>
	</div>
<script src ="essentials.js"></script>
<script src="crypto.js"></script>
<script src="external/jsQR.js"></script>
<template id="key-card-template">
	<div class="key-card">
		<div class="progress-line" style="position:absolute; top:0; left:0; height:2%; width:100%; background:#161b22;">
			<div class="progress-fill"></div>
		</div>

		<button class="delete-btn" title="Delete this key">&times;</button>

		<div class="public-values">
			<div class="title">
				<strong>Name:</strong>
				<span class="account-name" contenteditable="true" spellcheck="false"></span>
			</div>

			<div class="issuer" style="display:none;">
				<strong>Issuer:</strong>
				<span class="issuer-value"></span>
			</div>

			<div class="otp">
				<strong>OTP:</strong>
				<span class="otp-value">N/A</span>
			</div>

			<div class="status-wrapper">
				<div class="status-container">
					<strong>Status:</strong>
					<span class="status">Unknown</span>
				</div>
			</div>
		</div>
	</div>
</template>

<script>
const settings = {
	passwordHideOn: {
		label: "Hide Password Input",
		type: "checkbox",
		default: !/mobile/i.test(navigator.userAgent),
	},
	offlineMode: {
		label: "Offline Mode",
		type: "checkbox",
		default: true,
		onChange: async (value) => {
			if (!value && globalThis.location.protocol !== 'file:') {
				const confirmDisable = await customPrompt('Warning! Disabling offline mode can expose your data to arbitrary code if hosted externally and the environment compromised. Type "yes" to confirm.', 0, 0);
				if (confirmDisable?.trim().toLowerCase() !== 'yes') return false;
			}
			navigator.serviceWorker?.controller?.postMessage({
				type: 'SET_OFFLINE_MODE',
				value
			});
		}
	},
	updateURL: {
		label: "Encode secretkeys in current url hash",
		type: "checkbox",
		default: true,
		afterChange: (value) => {
			if (value) {
				updateURL();
			} else {
				history.replaceState(null, "", globalThis.location.origin + globalThis.location.pathname + globalThis.location.search);
			}
		}
	},
};

for (let key in settings) {
	config.defaults[key] = settings[key].default;
}
config.load();

navigator.serviceWorker?.controller?.postMessage({
	type: 'SET_OFFLINE_MODE',
	value: config.get('offlineMode')
});

// ================================
// localStorage management
// ================================
let masterKeys = [];
let keys = [];
let masterKeysRevealed = false;
let sessionEncKey = null;

function loadKeys() {
	let fromUrl = getKeysFromURL();
	const stored = localStorage.getItem("authKeys");

	if (stored) {
		keys = JSON.parse(stored);

		if (fromUrl) {
			fromUrl.forEach(fk => {
				const exists = keys.find(k => k.id === fk.id);
				if (!exists) keys.push(prepareKey(fk));
			});
		}

		keys = keys.map(k => prepareKey(k));

	} else if (fromUrl) {
		keys = fromUrl.map(k => prepareKey(k));
	} else {
		keys = [];
	}

	localStorage.setItem("authKeys", JSON.stringify(keys));
	updateURL();
}

function saveKeys() {
	const keysToStore = keys.map(({
		decryptedSecret,
		status,
		...rest
	}) => rest);
	localStorage.setItem("authKeys", JSON.stringify(keysToStore));
	updateURL();
}

async function loadMasterKeys() {
	const stored = localStorage.getItem("masterKeys");
	if (!stored) {
		masterKeys = [];
		sessionEncKey = null;
		updateURL();
		return;
	}

	try {
		const parsed = JSON.parse(stored);

		if (Array.isArray(parsed)) {
			masterKeys = parsed;
			sessionEncKey = null;
		} else if (parsed?.data && parsed?.iv && parsed?.salt) {
			let valid = false;
			while (!valid) {
				sessionEncKey = await prompt(
					"Enter master keys encryption key (or type 'CLEAR MASTERKEYS' to clear)",
					1, 1
				);
				if (sessionEncKey === "CLEAR MASTERKEYS") {
					localStorage.removeItem("masterKeys");
					masterKeys = [];
					sessionEncKey = null;
					break;
				}
				try {
					masterKeys = JSON.parse(await decryptText(stored, sessionEncKey));
					valid = true;
				} catch {
					alert("Incorrect key or corrupted data. Try again.");
				}
			}
		} else {
			console.warn("Unknown masterKeys format");
			masterKeys = [];
			sessionEncKey = null;
		}
	} catch {
		console.error("Failed to parse masterKeys");
		masterKeys = [];
		sessionEncKey = null;
	}
	updateURL();
}

async function saveMasterKeys() {
	if (sessionEncKey) {
		const jsonData = JSON.stringify(masterKeys);
		try {
			const encrypted = await encryptText(jsonData, sessionEncKey);
			localStorage.setItem("masterKeys", encrypted);
		} catch (e) {
			alert("Error encrypting master keys: " + e.message);
		}
	} else {
		localStorage.setItem("masterKeys", JSON.stringify(masterKeys));
	}
	updateURL();
}

async function changeMasterKeysEncryptionKey() {
	const newKey = await prompt("Enter a new key for encrypting master keys:", 1);
	if (!newKey) return;
	sessionEncKey = newKey;
	await saveMasterKeys();
	alert("Master keys encryption key successfully changed.");
	updateMasterEncryptionControls();
}
async function enableMasterKeysEncryption() {
	const newKey = await prompt("Enter the key to encrypt master keys:", 1);
	if (!newKey) return;
	sessionEncKey = newKey;
	await saveMasterKeys();
	alert("Master keys are now encrypted.");
	updateMasterEncryptionControls();
}
async function disableMasterKeysEncryption() {
	if (!confirm("Are you sure you want to disable encryption of master keys? They will be stored in plaintext.")) {
		return;
	}
	const decryptedKeys = masterKeys;
	sessionEncKey = null;
	masterKeys = decryptedKeys;
	await saveMasterKeys();
	alert("Encryption of master keys disabled.");
	updateMasterEncryptionControls();
}

// ================================
// UI Functions
// ================================

function filterKeyCards(query) {
  const q = query.trim().toLowerCase()
  document.querySelectorAll('.key-card').forEach(card => {
	const issuer = (card.querySelector('.issuer-value')?.textContent || '').toLowerCase()
	const account = (card.querySelector('.account-name')?.textContent || '').toLowerCase()
	card.style.display = (!q || issuer.includes(q) || account.includes(q)) ? 'block' : 'none'
  })
}

function updateMasterEncryptionControls() {
	const container = document.getElementById("masterEncryptionControls");
	container.innerHTML = "";
	if (sessionEncKey) {
		const changeBtn = document.createElement("button");
		changeBtn.textContent = "Change encryption key";
		changeBtn.addEventListener("click", changeMasterKeysEncryptionKey);
		container.appendChild(changeBtn);
		const disableBtn = document.createElement("button");
		disableBtn.textContent = "Disable encryption";
		disableBtn.style.backgroundColor = "var(--color-red)";
		disableBtn.addEventListener("click", disableMasterKeysEncryption);
		container.appendChild(disableBtn);
	} else {
		const enableBtn = document.createElement("button");
		enableBtn.textContent = "Enable master keys encryption";
		enableBtn.addEventListener("click", enableMasterKeysEncryption);
		container.appendChild(enableBtn);
	}
}

function deleteKey(keyObj) {
	if (confirm("Are you sure you want to delete this key?")) {
		keys = keys.filter((k) => k.id !== keyObj.id);
		saveKeys();
		const cardToDelete = document.getElementById("key-" + keyObj.id);
		if (cardToDelete) {
			cardToDelete.remove();
		}
		if (document.getElementById("managesecretKeysModal").style.display !== "none") {
			rendersecretKeysTable();
		}
	}
}
function showCopyModal(text) {
	const modal = document.getElementById("copyModal");
	const textarea = document.getElementById("copyTextArea");
	textarea.value = text;
	modal.style.display = "flex";
}

function createKeyCard(keyObj) {
	const template = document.getElementById("key-card-template");
	const card = template.content.firstElementChild.cloneNode(true);
	card.id = "key-" + keyObj.id;
	otpObserver.observe(card);

	const delBtn = card.querySelector(".delete-btn");
	delBtn.onclick = () => deleteKey(keyObj);

	const editableTitle = card.querySelector(".account-name");
	editableTitle.textContent = keyObj.accountName || keyObj.title || "Unknown";
	editableTitle.dataset.keyId = keyObj.id;
	editableTitle.addEventListener("blur", function() {
		const key = keys.find(k => k.id === this.dataset.keyId);
		if (key) {
			const newTitle = this.textContent.trim();
			if (newTitle && newTitle !== (key.accountName || key.title)) {
				key.accountName = newTitle;
				saveKeys();
				this.textContent = newTitle;
				if (document.getElementById("managesecretKeysModal").style.display !== "none") {
					rendersecretKeysTable();
				}
			}
		}
	});
	editableTitle.addEventListener("keydown", function(e) {
		if (e.key === "Enter") {
			e.preventDefault();
			this.blur();
		}
	});

	const issuerDiv = card.querySelector(".issuer");
	const issuerSpan = card.querySelector(".issuer-value");
	if (keyObj.issuer && keyObj.issuer !== "Unknown") {
		issuerSpan.textContent = keyObj.issuer;
		issuerDiv.style.display = "block";
	} else {
		issuerDiv.style.display = "none";
	}

	issuerSpan.contentEditable = true;
	issuerSpan.spellcheck = false;
	issuerSpan.dataset.keyId = keyObj.id;
	issuerSpan.addEventListener("blur", function() {
		const key = keys.find(k => k.id === this.dataset.keyId);
		if (key) {
			const newIssuer = this.textContent.trim();
			if (newIssuer && newIssuer !== key.issuer) {
				key.issuer = newIssuer;
				saveKeys();
				this.textContent = newIssuer;
			}
		}
	});
	issuerSpan.addEventListener("keydown", function(e) {
		if (e.key === "Enter") {
			e.preventDefault();
			this.blur();
		}
	});

	const otpSpan = card.querySelector(".otp-value");
	otpSpan.id = "otp-" + keyObj.id;
	otpSpan.addEventListener("click", function() {
		if (/^\d{6}$/.test(this.textContent)) {
			navigator.clipboard.writeText(this.textContent).then(() => alert("OTP copied!")).catch(e => alert("Copy failed: " + e.message));
		}
	});

	const statusSpan = card.querySelector(".status");
	statusSpan.id = "status-" + keyObj.id;
	statusSpan.dataset.keyId = keyObj.id;
	statusSpan.addEventListener("click", async function() {
		const keyId = this.dataset.keyId;
		const key = keys.find(k => k.id === keyId);
		if (!key) return;
		const mk = getMatchingMasterKey(key);
		if (!mk) return;
		try {
			const decryptedSecret = await decryptText(key.encryptedKey, mk.password);
			await navigator.clipboard.writeText(decryptedSecret);
			alert("Secret copied to clipboard!");
		} catch (e) {
			alert("Copy failed: " + e.message);
		}
	});

	const progressFill = card.querySelector(".progress-fill");
	progressFill.id = "progress-" + keyObj.id;
	const period = keyObj.period || 30;
	progressFill.dataset.period = period;

	return card;
}

async function renderKeys() {
    for (const keyObj of keys) {
        appendKeyCard(keyObj);
        await new Promise(requestAnimationFrame);
    }
}

function appendKeyCard(keyObj) {
	const container = document.getElementById("keysContainer");
	const keyCard = createKeyCard(keyObj);
	container.appendChild(keyCard);
}

function openModal(modalId, updateFunction) {
	if (updateFunction) {
		updateFunction();
	}
	document.getElementById(modalId).style.display = "flex";
}

function closeModal(modalId) {
	document.getElementById(modalId).style.display = "none";
}

async function openManageMasterModal() {
	openModal("manageMasterModal", () => {
		renderMasterKeysTable();
		updateMasterEncryptionControls();
	});
}

async function openManagesecretKeysModal() {
	openModal("managesecretKeysModal", async () => {
		await updateDecryptionForKeys();
		rendersecretKeysTable();
	});
}

function renderSettings() {
	const container = document.getElementById('settingsContainer');
	container.innerHTML = '';
	Object.entries(settings).forEach(([key, def]) => {
		const item = document.createElement('div');
		item.className = 'setting-item';
		item.style.display = 'flex';
		item.style.alignItems = 'center';
		item.style.justifyContent = 'space-between';
		item.style.marginBottom = '1em';
		const label = document.createElement('label');
		label.textContent = def.label;
		let input;
		if (def.type === 'checkbox') {
			input = document.createElement('input');
			input.type = 'checkbox';
			input.checked = config.get(key) ?? def.default;
			input.addEventListener('change', async () => {
				const value = input.checked;
				if (def.onChange) {
					const res = await def.onChange(value, input);
					if (res === false) {
						input.checked = config.get(key) ?? def.default;
						return;
					}
				}
				config.set(key, value);
				if (def.afterChange) {
					await def.afterChange(value, input);
				}
			});
			const switchLabel = document.createElement('label');
			switchLabel.className = 'switch';
			const span = document.createElement('span');
			span.className = 'slider round';
			switchLabel.appendChild(input);
			switchLabel.appendChild(span);
			item.appendChild(label);
			item.appendChild(switchLabel);
		} else {
			input = document.createElement('input');
			input.type = def.type;
			input.value = config.get(key) ?? def.default;
			input.addEventListener('change', async () => {
				let value;
				if (def.type === 'number') value = Number(input.value);
				else value = input.value;
				if (def.onChange) {
					const res = await def.onChange(value, input);
					if (res === false) {
						input.value = config.get(key) ?? def.default;
						return;
					}
				}
				config.set(key, value);
				if (def.afterChange) {
					await def.afterChange(value, input);
				}
			});
			item.appendChild(label);
			item.appendChild(input);
		}
		container.appendChild(item);
	});
}

function openSettingsModal() {
	renderSettings();
	document.getElementById("settingsModal").style.display = "flex";
}

function renderMasterKeysTable() {
	const tbody = document.querySelector("#masterKeysTable tbody");
	tbody.innerHTML = "";
	masterKeys.forEach((mk) => {
		const usageCount = keys.filter(
			(keyObj) => keyObj.masterKeyHash === mk.hash).length;
		const tr = document.createElement("tr");
		const tdMasterKey = document.createElement("td");
		tdMasterKey.className = "master-key-cell";
		tdMasterKey.textContent = masterKeysRevealed ? mk.password : "Click to copy key";
		tdMasterKey.addEventListener("click", async function() {
			try {
				await navigator.clipboard.writeText(mk.password);
				alert("Master key copied to clipboard!");
			} catch (e) {
				alert("Copy failed: " + e.message);
			}
		});
		tr.appendChild(tdMasterKey);
		const hashToDisplay = globalThis.innerWidth < 768 ? mk.hash.slice(0, 15) + "..." : mk.hash;
		const tdHash = document.createElement("td");
		tdHash.textContent = hashToDisplay;
		tr.appendChild(tdHash);
		const tdUsage = document.createElement("td");
		tdUsage.textContent = usageCount;
		tr.appendChild(tdUsage);
		const tdActions = document.createElement("td");
		const delBtn = document.createElement("button");
		delBtn.textContent = "Delete";
		delBtn.onclick = function() {
			if (confirm("Delete this master key?")) {
				masterKeys = masterKeys.filter((key) => key.hash !== mk.hash);
				saveMasterKeys();
				tr.remove();
				updateAffectedKeys(mk.hash);
			}
		};
		tdActions.appendChild(delBtn);
		tr.appendChild(tdActions);
		tbody.appendChild(tr);
	});
}

function updateAffectedKeys(deletedHash) {
	keys.forEach((keyObj) => {
		if (keyObj.masterKeyHash === deletedHash) {
			keyObj.decryptedSecret = null;
			const statusElement = document.getElementById(`status-${keyObj.id}`);
			if (statusElement) {
				statusElement.textContent = "Encrypted";
				statusElement.classList.add("status-encrypted");
				statusElement.classList.remove("status-decrypted");
			}
		}
	});
}

function rendersecretKeysTable() {
	const table = document.querySelector("#secretKeysTable");
	const tbody = table.querySelector("tbody");
	tbody.innerHTML = "";

	const thead = table.querySelector("thead");
	thead.innerHTML = "";
	if (keys.length > 0) {
		const headerRow = document.createElement("tr");
		Object.keys(keys[0]).forEach(key => {
			const th = document.createElement("th");
			th.textContent = key;
			headerRow.appendChild(th);
		});
		const thActions = document.createElement("th");
		thActions.textContent = "Actions";
		headerRow.appendChild(thActions);
		thead.appendChild(headerRow);
	}

	keys.forEach(keyObj => {
		const tr = document.createElement("tr");

		for (const [key, value] of Object.entries(keyObj)) {
			const td = document.createElement("td");
			let displayValue = value;

			if (key === "id" || key === "masterKeyHash") {
				displayValue = String(value).slice(0, 8) + "...";
			}

			if (key === "encryptedKey") {
				displayValue = "Click to copy";
			}

			td.textContent = displayValue;
			td.addEventListener("click", async function() {
				if (key === "encryptedKey") {
					const mk = getMatchingMasterKey(keyObj);
					if (!mk) {
						alert("Master key not available.");
						return;
					}
					try {
						const decryptedSecret = await decryptText(keyObj.encryptedKey, mk.password);
						await navigator.clipboard.writeText(decryptedSecret);
						alert("Secret copied to clipboard!");
					} catch (e) {
						alert("Decryption failed: " + e.message);
					}
				} else {
					await navigator.clipboard.writeText(String(value));
					alert("Value copied to clipboard!");
				}
			});

			tr.appendChild(td);
		}

		const tdActions = document.createElement("td");
		const delBtn = document.createElement("button");
		delBtn.textContent = "Delete";
		delBtn.onclick = () => deleteKey(keyObj);
		tdActions.appendChild(delBtn);
		tr.appendChild(tdActions);

		tbody.appendChild(tr);
	});
}

// ================================
// OTP Functions
// ================================

function getMatchingMasterKey(keyObj) {
	return masterKeys.find(mk => mk.hash === keyObj.masterKeyHash);
}

async function updateKeyCard(keyObj) {
	const otpSpan = document.getElementById("otp-" + keyObj.id);
	const statusSpan = document.getElementById("status-" + keyObj.id);
	const titleSpan = document.querySelector(`.account-name[data-key-id="${keyObj.id}"]`);

	if (titleSpan) titleSpan.textContent = keyObj.accountName;

	const mk = getMatchingMasterKey(keyObj);

	if (!mk) {
		otpSpan.textContent = "N/A";
		statusSpan.textContent = "Encrypted";
		statusSpan.className = "status status-encrypted";
		return;
	}

	try {
		const otp = await generateOTP({
			...keyObj,
			secret: await decryptText(keyObj.encryptedKey, mk.password)
		});
		otpSpan.textContent = otp;
		statusSpan.textContent = "Decrypted";
		statusSpan.className = "status status-decrypted";
	} catch (err) {
		otpSpan.textContent = "N/A";
		statusSpan.textContent = "Decryption error";
		statusSpan.className = "status status-failed";
		console.error(`Error decrypting keyObj id=${keyObj.id}:`, err);
	}
}

function updateDecryptionForKeys() {
	if (!masterKeys.length) {
		keys.forEach(keyObj => keyObj.status = "encrypted");
		return;
	}

	keys.forEach(keyObj => {
		const mk = getMatchingMasterKey(keyObj);
		keyObj.status = mk && keyObj.masterKeyHash === mk.hash ? "decrypted" : mk ? "failed" : "encrypted";
	});
}

function decryptKey(keyObj, mk) {
	return keyObj.masterKeyHash === mk.hash ? "decrypted" : "encrypted";
}

// ================================
// Export and Import
// ================================

function prepareKey(keyObj, options = {}) {
	let accountName = keyObj.accountName || keyObj.title || "Unknown";
	let issuer = keyObj.issuer || "Unknown";

	if (issuer && accountName.startsWith(issuer + ":")) {
		accountName = accountName.slice((issuer + ":").length);
	}
	accountName = accountName.trim();

	const KeyObj = { 
		id: keyObj.id,
		accountName,
		encryptedKey: keyObj.encryptedKey,
		masterKeyHash: keyObj.masterKeyHash || keyObj.encryptionHash,
		issuer,
		digits: keyObj.digits || 6,
		period: keyObj.period || 30,
		algorithm: keyObj.algorithm || "SHA1"
	};

	if (options.shortImport) {
		if (KeyObj.digits === 6) delete KeyObj.digits;
		if (KeyObj.period === 30) delete KeyObj.period;
		if (KeyObj.algorithm === "SHA1") delete KeyObj.algorithm;
		if (KeyObj.issuer === "Unknown") delete KeyObj.issuer;
	}

	return KeyObj;
}

async function exportData(toFile = false, shortImport = false) {
	const password = await prompt("Enter password for exporting data (use 'raw' for no encryption):", 1);
	if (!password) return;

	try {
		const output = await processExport(keys, masterKeys, password, shortImport);
		
		if (toFile) {
			const now = new Date();
			const timestamp = now.toISOString().replace(/[:.]/g, "-");
			const filename = `${timestamp}.keystore`;
			const blob = new Blob([output], { type: "text/plain" });
			const url = URL.createObjectURL(blob);
			const a = document.createElement("a");
			a.href = url;
			a.download = filename;
			a.click();
			URL.revokeObjectURL(url);
			alert("Data exported to file: " + filename);
		} else {
			try {
				await navigator.clipboard.writeText(output);
				alert("Data successfully exported and copied to clipboard!");
			} catch {
				showCopyModal(output);
			}
		}
	} catch (e) {
		alert("Error exporting data: " + e.message);
	}
}

async function processExport(keysList, masterKeysList, password, shortImport = false) {
	const keysForExport = keysList.map(k => prepareKey(k, { shortImport }));
	const combined = JSON.stringify({ keys: keysForExport, masterKeys: masterKeysList });

	if (password === "raw") return combined;

	return await encryptText(combined, password);
}

async function importData(fromFile = false) {
	if (fromFile) {
		const fileInput = document.createElement("input");
		fileInput.type = "file";
		fileInput.accept = ".keystore";
		fileInput.onchange = async (event) => {
			const file = event.target.files[0];
			if (!file) return;
			const reader = new FileReader();
			reader.onload = async () => {
				await processImport(reader.result);
			};
			reader.readAsText(file);
		};
		fileInput.click();
	} else {
		const input = await prompt("Paste the string to import data:");
		if (input) await processImport(input.trim());
	}
}

async function processImport(input) {
	let combined;

	try {
		combined = JSON.parse(input);
		if (!combined.keys) {
			const password = await prompt("Enter password for encrypted data:", 1);
			if (!password) return;
			combined = JSON.parse(await decryptText(input, password));
		}
	} catch (e) {
		console.error("Failed to parse/import data:", e);
		alert("Failed to import data: " + e.message);
		return;
	}

	try {
		let newKeys = combined.keys ? combined.keys.map(k => prepareKey(k, { shortImport: false })) : [];

		newKeys.forEach(newKey => {
			const existingKey = keys.find(k => k.id === newKey.id);
			if (existingKey) {
				if (existingKey.accountName !== newKey.accountName) {
					existingKey.accountName = newKey.accountName;
					updateKeyCard(existingKey).catch(err => console.error(`Error updating key card id=${existingKey.id}:`, err));
				}
			} else {
				keys.push(newKey);
				appendKeyCard(newKey);
			}
		});

		await saveKeys();

		if (combined.masterKeys) {
			let addedAnyMasterKey = false;

			for (const mk of combined.masterKeys) {
				if (!masterKeys.some(existing => existing.hash === mk.hash)) {
					masterKeys.push(mk);
					addedAnyMasterKey = true;
				}
			}

			if (addedAnyMasterKey) {
				await saveMasterKeys();

				keys.forEach(keyObj => {
					const mkMatch = masterKeys.some(mk => mk.hash === keyObj.masterKeyHash);
					if (mkMatch) {
						updateKeyCard(keyObj).catch(err => console.error(`Error updating key card id=${keyObj.id}:`, err));
					}
				});
			}
		}
	} catch (e) {
		console.error("Error processing imported data:", e);
		alert("Error processing imported data: " + e.message);
	}
}

// ================================
// Init and Event Listeners
// ================================

function initEventListeners() {
	document.getElementById("copyButton").addEventListener("click", async function() {
		const textarea = document.getElementById("copyTextArea");
		try {
			await navigator.clipboard.writeText(textarea.value);
			alert("Copied to clipboard!");
		} catch (e) {
			alert("Copy failed: " + e.message);
		}
		document.getElementById("copyModal").style.display = "none";
	});
	document.getElementById("clearStorageBtn").addEventListener("click", function() {
		if (!confirm("Are you sure you want to permanently clear all data? This action cannot be undone.")) {
			return;
		}
		localStorage.removeItem("authKeys");
		localStorage.removeItem("masterKeys");
		localStorage.removeItem("masterKeysEncKeyHash");
		history.replaceState(null, "", globalThis.location.pathname);
		sessionEncKey = null;
		loadKeys();
		loadMasterKeys();
		renderKeys();
	});
	globalThis.addEventListener("click", function(event) {
		const modals = [{
			element: document.getElementById("manageMasterModal"),
			closeFunction: () => closeModal("manageMasterModal")
		}, {
			element: document.getElementById("managesecretKeysModal"),
			closeFunction: () => closeModal("managesecretKeysModal")
		}, {
			element: document.getElementById("settingsModal"),
			closeFunction: () => closeModal("settingsModal")
		}, {
			element: document.getElementById("addKeyUIModal"),
			closeFunction: () => closeModal("addKeyUIModal")
		}, {
			element: document.getElementById("qrScannerModal"),
			closeFunction: () => closeModal("qrScannerModal")
		}];
		modals.forEach(modal => {
			if (event.target === modal.element) {
				modal.closeFunction();
			}
		});
	});
	document.getElementById("toggleRevealMasterKeysBtn")?.addEventListener("click", function() {
		masterKeysRevealed = !masterKeysRevealed;
		this.textContent = masterKeysRevealed ? "Hide master keys" : "Reveal master keys";
		renderMasterKeysTable();
	});
}

function startCameraScan() {
	closeModal('addKeyUIModal');
	openModal('qrScannerModal');
	startCamera();
}

function handleFileSelection(event) {
	const files = Array.from(event.target.files);
	files.forEach(file => {
		const reader = new FileReader();
		const img = new Image();
		reader.onload = function(e) {
			img.src = e.target.result;
			img.onload = function() {
				parseQRCode(img);
			};
		};
		reader.readAsDataURL(file);
	});
}

function startCamera() {
	const video = document.getElementById('video');
	navigator.mediaDevices.getUserMedia({
		video: {
			facingMode: "environment"
		}
	}).then(stream => {
		video.srcObject = stream;
		video.setAttribute("playsinline", true);
		video.play();
		requestAnimationFrame(scanQRCode);
	}).catch(err => console.warn(err));
}

function stopCamera() {
	const video = document.getElementById('video');
	if (video.srcObject) {
		video.srcObject.getTracks().forEach(track => track.stop());
		video.srcObject = null;
	}
}

function scanQRCode() {
	const video = document.getElementById('video');
	const canvas = document.getElementById('canvas');
	canvas.willReadFrequently = true;
	const ctx = canvas.getContext('2d');
	const modal = document.getElementById('qrScannerModal');
	if (modal.style.display !== "flex") {
		stopCamera();
		return;
	}
	if (video.readyState === video.HAVE_ENOUGH_DATA) {
		canvas.height = video.videoHeight;
		canvas.width = video.videoWidth;
		ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
		const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
		const qrCode = jsQR(imageData.data, canvas.width, canvas.height);
		if (qrCode) {
			addKeyFromQRText(qrCode.data);
			closeModal("qrScannerModal");
		}
	}
	requestAnimationFrame(scanQRCode);
}

function parseQRCode(image) {
	const canvas = document.getElementById('canvas');
	canvas.willReadFrequently = true;
	const ctx = canvas.getContext('2d');
	canvas.width = image.width;
	canvas.height = image.height;
	ctx.drawImage(image, 0, 0);
	const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
	const qrCode = jsQR(imageData.data, canvas.width, canvas.height);
	if (qrCode) {
		addKeyFromQRText(qrCode.data);
	} else {
		alert('QR code not found.');
	}
}

function addKeyFromQRText(qrText) {

	if (qrText.startsWith('otpauth-migration://')) {
		const urlObj = new URL(qrText);
		let dataParam = urlObj.searchParams.get('data');
		if (dataParam) {
			dataParam = decodeURIComponent(dataParam);
			parseOtpauthMigration(dataParam);
		}
		return;
	}

	const prefix = 'otpauth://totp/';
	if (!qrText.startsWith(prefix)) {
		console.warn('QR text does not start with expected prefix. Full text:', qrText);
		alert('Invalid QR code format.');
		return;
	}

	const decodedQRText = decodeURIComponent(qrText);
	const remainingText = decodedQRText.slice(prefix.length);

	const [path, queryString] = remainingText.split('?');

	const urlParams = new URLSearchParams(queryString);
	const secret = urlParams.get('secret');
	const issuer = urlParams.get('issuer') || '';
	const digits = Number.parseInt(urlParams.get('digits')) || 6;
	const period = Number.parseInt(urlParams.get('period')) || 30;
	const algorithm = urlParams.get('algorithm') || 'SHA1';

	const keyOptions = prepareKey({
		accountName: path,
		issuer,
		digits,
		period,
		algorithm
	}, { shortImport: true });

	addKeyUI(path, secret, keyOptions);
}

const protoDefinition = {
	Payload: {
		fields: {
			otp_parameters: { type: "OtpParameters", repeated: true, id: 1 },
			version: { type: "int32", id: 2 },
			batch_size: { type: "int32", id: 3 },
			batch_index: { type: "int32", id: 4 },
			batch_id: { type: "int32", id: 5 }
		}
	},
	OtpParameters: {
		fields: {
			secret: { type: "bytes", id: 1 },
			name: { type: "string", id: 2 },
			issuer: { type: "string", id: 3 },
			algorithm: { type: "Algorithm", id: 4 },
			digits: { type: "DigitCount", id: 5 },
			type: { type: "OtpType", id: 6 },
			counter: { type: "uint64", id: 7 },
			unique_id: { type: "string", id: 8 }
		}
	},
	OtpType: {
		0: "OTP_TYPE_UNSPECIFIED",
		1: "HOTP",
		2: "TOTP"
	},
	Algorithm: {
		0: "ALGORITHM_UNSPECIFIED",
		1: "SHA1",
		2: "SHA256",
		3: "SHA512",
		4: "MD5"
	},
	DigitCount: {
		0: "DIGIT_COUNT_UNSPECIFIED",
		1: "6",
		2: "8"
	}
};

function parseMigrationPayload(bytes) {
	const readVarint = (buf, offset) => {
		let val = 0, shift = 0, pos = offset;
		while (true) {
			const b = buf[pos++];
			val |= (b & 0x7f) << shift;
			if (!(b & 0x80)) break;
			shift += 7;
		}
		return { value: val, length: pos - offset };
	};

	const tryText = u => { try { return new TextDecoder().decode(u); } catch { return null; } };
	const parseEnum = (e, v) => e[v] ?? v;

	const otpFields = protoDefinition.OtpParameters.fields;

	let pos = 0, payload = { otpParameters: [] };

	while (pos < bytes.length) {
		const { value: keyVal, length: keyLen } = readVarint(bytes, pos); pos += keyLen;
		const field = keyVal >> 3, wireType = keyVal & 0x7;

		if (wireType === 0) {
			const { value, length } = readVarint(bytes, pos); pos += length;
			payload[field] = value;
		} else if (wireType === 2) {
			const { value: len, length: lenLen } = readVarint(bytes, pos); pos += lenLen;
			const slice = bytes.slice(pos, pos + len); pos += len;
			if (field === 1) {
				let ipos = 0, param = {};
				while (ipos < slice.length) {
					const { value: k, length: kl } = readVarint(slice, ipos); ipos += kl;
					const f = k >> 3, wt = k & 0x7;
					const fieldDef = Object.entries(otpFields).find(([name, def]) => def.id === f);
					if (!fieldDef) { ipos += wt === 2 ? readVarint(slice, ipos).value : 0; continue; }

					const [name, def] = fieldDef;

					if (wt === 0) {
						const { value, length } = readVarint(slice, ipos); ipos += length;
						if (def.type === "OtpType") param[name] = parseEnum(protoDefinition.OtpType, value);
						else if (def.type === "Algorithm") param[name] = parseEnum(protoDefinition.Algorithm, value);
						else if (def.type === "DigitCount") param[name] = parseEnum(protoDefinition.DigitCount, value);
						else param[name] = value;
					} else if (wt === 2) {
						const { value: l, length: ll } = readVarint(slice, ipos); ipos += ll;
						const s = slice.slice(ipos, ipos + l); ipos += l;
						if (def.type === "string") param[name] = tryText(s);
						else param[name] = s;
					} else break;
				}
				payload.otpParameters.push(param);
			}
		} else break;
	}

	return payload;
}

function parseOtpauthMigration(dataParam) {
	try {
		if (!dataParam) throw new Error("data parameter is empty");
		const bytes = base64ToUint8Array(dataParam);
		const payload = parseMigrationPayload(bytes);

		payload.otpParameters.forEach((param) => {
			if (!param.secret) return;
			const base32Secret = base64ToBase32(btoa(String.fromCharCode(...param.secret)));
			const keyOptions = prepareKey({
				accountName: param.name,
				issuer: param.issuer,
				digits: param.digits,
				period: param.period,
				algorithm: param.algorithm
			}, { shortImport: false });

			addKeyUI(param.name, base32Secret, keyOptions);
		});

	} catch (error) {
		console.error("Error parsing otpauth-migration:", error.message);
	}
}

async function addKey(accountName, keyValue, masterKey, options = {}) {
	const encrypted = await encryptText(keyValue, masterKey.password);
	const id = await sha256(accountName + keyValue);

	let keyObj = {
		id: id,
		accountName: accountName,
		encryptedKey: encrypted,
		masterKeyHash: masterKey.hash,
		issuer: options.issuer,
		digits: options.digits,
		period: options.period,
		algorithm: options.algorithm
	};

	keyObj = prepareKey(keyObj);

	if (!keys.find(k => k.id === id)) keys.push(keyObj);
	saveKeys();
	return keyObj;
}

async function addKeyUI(accountName = null, keyValue = null, options = {}) {
	if (!accountName) {
		accountName = await prompt("Enter key name:");
		if (!accountName) return;
	}
	if (!keyValue) {
		keyValue = await prompt("Enter key value (secret):", 1);
		if (!keyValue) return;
	}

	const selectedMasterKey = await chooseMasterKey();
	if (!selectedMasterKey) return;

	try {
		const id = await sha256(accountName + keyValue);

		if (keys.find(k => k.id === id)) {
			alert(`Key ${accountName} already imported!`);
			return;
		}

		const keyObj = await addKey(accountName, keyValue, selectedMasterKey, options);
		appendKeyCard(keyObj);
		updateKeyCard(keyObj);
		closeModal('addKeyUIModal');
	} catch (e) {
		alert("Error encrypting key: " + e.message);
	}
}

async function chooseMasterKey() {
	if (masterKeys.length === 0) {
		await addMasterKey();
	}
	if (masterKeys.length === 1) {
		return masterKeys[0];
	} else {
		while (true) {
			const options = masterKeys.map(
				(mk, idx) => (idx + 1) + ": " + mk.hash.substring(0, 6) + "..." + " (" + mk.password.substring(0, 4) + "...)").join("\n");
			const choice = await prompt("Choose a master key for encryption:\n0. Add new master key\n" + options);
			const index = Number.parseInt(choice) - 1;
			if (index >= 0 && index < masterKeys.length) {
				return masterKeys[index];
			} else if (index === masterKeys.length) {
				await addMasterKey();
				return await chooseMasterKey();
			}
		}
	}
}

async function addMasterKey() {
	const input = await prompt("Enter master key:", 1);
	if (!input) return;

	const hash = await sha256(input);
	if (masterKeys.some(mk => mk.hash === hash)) {
		return;
	}

	masterKeys.push({ password: input, hash: hash });
	await saveMasterKeys();

	keys.forEach(keyObj => {
		if (keyObj.masterKeyHash === hash) {
			updateKeyCard(keyObj);
		}
	});

	if (document.getElementById("manageMasterModal").style.display !== "none") {
		renderMasterKeysTable();
	}
}

const visibleCards = new Set();
const otpObserver = new IntersectionObserver((entries) => {
	entries.forEach(entry => {
		const cardId = entry.target.id;
		if (entry.isIntersecting) {
			visibleCards.add(cardId);
		} else {
			visibleCards.delete(cardId);
		}
	});
}, {
	root: null,
	rootMargin: '50% 0% 50% 0%',
	threshold: 0
});

function startOTPUpdater() {
	function update() {
		const now = Date.now();

		visibleCards.forEach(cardId => {
			const card = document.getElementById(cardId);
			if (!card) return;

			const keyObj = keys.find(k => k.id === cardId.replace(/^key-/, ""));
			if (!keyObj) return;

			const progressEl = card.querySelector(".progress-fill");
			const periodSec = progressEl ? Number.parseFloat(progressEl.dataset.period) || 30 : 30;
			const periodMs = periodSec * 1000;

			const timeStep = Math.floor(now / periodMs);
			if (Number.parseInt(card.dataset.lastStep) !== timeStep) {
				updateKeyCard(keyObj);
				card.dataset.lastStep = timeStep;
			}

			if (progressEl) {
				const elapsed = (now % periodMs) / periodMs;
				progressEl.style.width = (elapsed * 100) + "%";
			}
		});

		requestAnimationFrame(update);
	}

	update();
}

async function init() {
	loadKeys();
	await loadMasterKeys();
	startOTPUpdater();
	renderKeys();
	initEventListeners();
	document.querySelector('.buttonContainer').style.display = 'flex';
}
document.addEventListener("DOMContentLoaded", init);

	</script>
  </body>
</html>
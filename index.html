<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" href="icon.png" type="image/png" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>WebOTP</title>
	<link rel="manifest" href="manifest.json">
    <link rel="stylesheet" href="styles.css" />
  </head>
  <body>
    <header>
      <h1>WebOTP</h1>
      <div id="encControls"></div>
    </header>
    <main>
<div id="keysContainer"></div>
<div class="buttonContainer">
  <button id="addKeyUIBtn" onclick="openModal('addKeyUIModal')">Add Key</button>
  <button class="addMasterKeyBtn" onclick="addMasterKey()">Add master key</button>
  <button id="managesecretKeysBtn" onclick="openManagesecretKeysModal()">My secret keys</button>
  <button id="manageMasterKeysBtn" onclick="openManageMasterModal()">My master keys</button>
  <br/>
  <button id="clearStorageBtn">Clear All Data</button>
  <button id="settingsBtn" onclick="openSettingsModal()">Settings</button>
</div>

    </main>
    <div id="notification" class="notification">
      <p></p>
    </div>
    <div id="copyModal">
      <div id="copyModalContent">
        <textarea id="copyTextArea" readonly></textarea>
        <button id="copyButton">Copy</button>
      </div>
    </div>
    <div id="manageMasterModal" class="modal">
      <div id="manageMasterModalContent" class="modal-content">
        <span id="closeManageMasterModal" class="close" onclick="closeModal('manageMasterModal');">&times;</span>
        <h2 style="text-align: center;">Master Keys</h2>
        <table id="masterKeysTable">
          <thead>
            <tr>
              <th>Master key</th>
              <th>SHA256</th>
              <th>Usage Count</th>
              <th>Actions</th>
            </tr>
          </thead>
          <tbody></tbody>
        </table>
        <div style="text-align: center; margin-top: 20px;">
          <button class="addMasterKeyBtn" onclick="addMasterKey()">Add master key</button>
          <button id="toggleRevealMasterKeysBtn">Reveal master keys</button>
        </div>
        <div id="masterEncryptionControls" style="text-align: center; margin-top: 10px;"></div>
      </div>
    </div>
	<div id="addKeyUIModal" class="modal">
	  <div class="modal-content">
		<span id="closeaddKeyUIModal" class="close" onclick="closeModal('addKeyUIModal');">&times;</span>
		<h2 style="text-align: center;">Choose Source</h2>
		<div style="text-align: center;">
		  <button onclick="startCameraScan()">From Camera (QR)</button>
		  <br>
		  <input type="file" id="file-input" accept="image/*" style="display: none;" multiple onchange="handleFileSelection(event)">
		  <button onclick="document.getElementById('file-input').click()">From Gallery (QR)</button>
		  <br>
		  <button onclick="addKeyUI()">From Secret Key (TEXT)</button>
		</div>
	  </div>
	</div>
	<div id="qrScannerModal" class="modal">
	  <div class="modal-content">
		<span class="close" onclick="closeModal('qrScannerModal');">&times;</span>
		<h2>Scan QR Code</h2>
		<video id="video" width="300" height="300" autoplay></video>
		<canvas id="canvas" style="display: none;"></canvas>
		<div style="text-align: center;">
		  <p id="qr-result">Waiting for QR scan...</p>
		</div>
	  </div>
	</div>
	<div id="managesecretKeysModal" class="modal">
	  <div id="managesecretKeysModalContent" class="modal-content">
		<span id="closeManagesecretKeysModal" class="close" onclick="closeModal('managesecretKeysModal');">&times;</span>
		<h2 style="text-align: center;">Secret Keys</h2>
		<table id="secretKeysTable">
		  <thead></thead>
		  <tbody></tbody>
		</table>
	  </div>
	</div>
    <dialog id="customPromptDialog">
      <form method="dialog">
        <p id="customPromptText"></p>
        <input type="text" id="customPromptInput" autocomplete="off" />
        <div style="text-align: center;">
          <button type="submit" id="customPromptOk">OK</button>
          <button type="button" id="customPromptCancel">Cancel</button>
        </div>
      </form>
    </dialog>
	<div id="settingsModal" class="modal">
	  <div id="settingsModalContent" class="modal-content">
		<span id="closeSettingsModal" class="close" onclick="closeModal('settingsModal');">&times;</span>
		<h2 style="text-align: center;">Settings</h2>
		<div id="settingsContainer"></div>
		<div id="additionalSettings" style="text-align: center; margin-top: 20px;">
		  <div class="buttonContainer">
			<button id="exportTextBtn" onclick="exportData(false)">Export String</button>
			<button id="exportFileBtn" onclick="exportData(true)">Export File</button>
			<button id="importTextBtn" onclick="importData(false)">Import String</button>
			<button id="importFileBtn" onclick="importData(true)">Import File</button>
		  </div>
		</div>
	  </div>
	</div>
<script src="crypto.js"></script>
<script src ="essentials.js"></script>
<script src="external/jsQR.js"></script>
<script src="external/protobuf.js"></script>
<script>

if (window.location.href.includes('eruda=true')) {
    console.log("Eruda detected in URL, injecting...");
    const script = document.createElement('script');
    script.src = "https://cdn.jsdelivr.net/npm/eruda";
    script.onload = () => {
        eruda.init();
    };
    document.body.appendChild(script);
}
</script>

<script>
const settings = {
	passwordHideOn: {
		label: "Hide Password Input",
		type: "checkbox",
		default: !/mobile/i.test(navigator.userAgent),
	},
	offlineMode: {
		label: "Offline Mode",
		type: "checkbox",
		default: true,
		onChange: async (value) => {
			if (!value && window.location.protocol !== 'file:') {
				const confirmDisable = await customPrompt('Warning! Disabling offline mode can expose your data to arbitrary code if hosted externally and the environment compromised. Type "yes" to confirm.', 0, 0);
				if (confirmDisable?.trim().toLowerCase() !== 'yes') return false;
			}
			navigator.serviceWorker?.controller?.postMessage({
				type: 'SET_OFFLINE_MODE',
				value
			});
		}
	},
	updateURL: {
		label: "Encode secretkeys in current url hash",
		type: "checkbox",
		default: true,
		afterChange: (value) => {
			if (value) {
				updateURL();
			} else {
				history.replaceState(null, "", window.location.origin + window.location.pathname + window.location.search);
			}
		}
	},
};

for (let key in settings) {
	config.defaults[key] = settings[key].default;
}
config.load();

// ================================
// localStorage management
// ================================
let masterKeys = [];
let keys = [];
let masterKeysRevealed = false;
let sessionEncKey = null;
let secretKeysRevealed = false;

function loadKeys() {
    let fromUrl = getKeysFromURL();
    const stored = localStorage.getItem("authKeys");

    if (stored) {
        keys = JSON.parse(stored);

        if (fromUrl) {
            fromUrl.forEach(fk => {
                const exists = keys.find(k => k.id === fk.id);
                if (!exists) keys.push(prepareKey(fk));
            });
        }

        keys = keys.map(k => prepareKey(k));

    } else if (fromUrl) {
        keys = fromUrl.map(k => prepareKey(k));
    } else {
        keys = [];
    }

    localStorage.setItem("authKeys", JSON.stringify(keys));
    updateURL();
}

function mergeKeys(fromUrl) {
    for (const keyObj of fromUrl) {
        if (!keys.find((k) => k.id === keyObj.id)) {
            keys.push(keyObj);
        }
    }
    localStorage.setItem("authKeys", JSON.stringify(keys));
}

function saveKeys() {
	const keysToStore = keys.map(({
		decryptedSecret,
		status,
		...rest
	}) => rest);
	localStorage.setItem("authKeys", JSON.stringify(keysToStore));
	updateURL();
}

async function loadMasterKeys() {
	const stored = localStorage.getItem("masterKeys");
	if (!stored) {
		masterKeys = [];
		sessionEncKey = null;
		updateURL();
		updateEncButton();
		return;
	}

	try {
		const parsed = JSON.parse(stored);

		if (Array.isArray(parsed)) {
			masterKeys = parsed;
			sessionEncKey = null;
		} else if (parsed?.data && parsed?.iv && parsed?.salt) {
			let valid = false;
			while (!valid) {
				sessionEncKey = await prompt(
					"Enter master keys encryption key (or type 'CLEAR MASTERKEYS' to clear)",
					1, 1
				);
				if (sessionEncKey === "CLEAR MASTERKEYS") {
					localStorage.removeItem("masterKeys");
					masterKeys = [];
					sessionEncKey = null;
					break;
				}
				try {
					masterKeys = JSON.parse(await decryptText(stored, sessionEncKey));
					valid = true;
				} catch {
					alert("Incorrect key or corrupted data. Try again.");
				}
			}
		} else {
			console.warn("Unknown masterKeys format");
			masterKeys = [];
			sessionEncKey = null;
		}
	} catch {
		console.error("Failed to parse masterKeys");
		masterKeys = [];
		sessionEncKey = null;
	}
	updateURL();
	updateEncButton();
}

async function saveMasterKeys() {
	if (sessionEncKey) {
		const jsonData = JSON.stringify(masterKeys);
		try {
			const encrypted = await encryptText(jsonData, sessionEncKey);
			localStorage.setItem("masterKeys", encrypted);
		} catch (e) {
			alert("Error encrypting master keys: " + e.message);
		}
	} else {
		localStorage.setItem("masterKeys", JSON.stringify(masterKeys));
	}
	updateURL();
}

async function changeMasterKeysEncryptionKey() {
	const newKey = await prompt("Enter a new key for encrypting master keys:", 1);
	if (!newKey) return;
	sessionEncKey = newKey;
	await saveMasterKeys();
	alert("Master keys encryption key successfully changed.");
	updateEncButton();
	updateMasterEncryptionControls();
}
async function enableMasterKeysEncryption() {
	const newKey = await prompt("Enter the key to encrypt master keys:", 1);
	if (!newKey) return;
	sessionEncKey = newKey;
	await saveMasterKeys();
	alert("Master keys are now encrypted.");
	updateEncButton();
	updateMasterEncryptionControls();
}
async function disableMasterKeysEncryption() {
	if (!confirm("Are you sure you want to disable encryption of master keys? They will be stored in plaintext.")) {
		return;
	}
	const decryptedKeys = masterKeys;
	sessionEncKey = null;
	masterKeys = decryptedKeys;
	await saveMasterKeys();
	alert("Encryption of master keys disabled.");
	updateEncButton();
	updateMasterEncryptionControls();
}

// ================================
// UI Functions
// ================================

function updateEncButton() {
	const controlsDiv = document.getElementById("encControls");
	controlsDiv.innerHTML = "";
	const button = document.createElement("button");
	if (sessionEncKey) {
		button.style.display = "none";
	} else {
		button.textContent = "Master keys unencrypted!";
		button.style.backgroundColor = "#d73a49";
	}
	button.addEventListener("click", openManageMasterModal);
	controlsDiv.appendChild(button);
}

function updateMasterEncryptionControls() {
	const container = document.getElementById("masterEncryptionControls");
	container.innerHTML = "";
	if (sessionEncKey) {
		const changeBtn = document.createElement("button");
		changeBtn.textContent = "Change encryption key";
		changeBtn.addEventListener("click", changeMasterKeysEncryptionKey);
		container.appendChild(changeBtn);
		const disableBtn = document.createElement("button");
		disableBtn.textContent = "Disable encryption";
		disableBtn.addEventListener("click", disableMasterKeysEncryption);
		container.appendChild(disableBtn);
	} else {
		const enableBtn = document.createElement("button");
		enableBtn.textContent = "Enable master keys encryption";
		enableBtn.addEventListener("click", enableMasterKeysEncryption);
		container.appendChild(enableBtn);
	}
}

function deleteKey(keyObj) {
	if (confirm("Are you sure you want to delete this key?")) {
		keys = keys.filter((k) => k.id !== keyObj.id);
		saveKeys();
		const cardToDelete = document.getElementById("key-" + keyObj.id);
		if (cardToDelete) {
			cardToDelete.remove();
		}
		if (document.getElementById("managesecretKeysModal").style.display !== "none") {
			rendersecretKeysTable();
		}
	}
}
function showCopyModal(text) {
	const modal = document.getElementById("copyModal");
	const textarea = document.getElementById("copyTextArea");
	textarea.value = text;
	modal.style.display = "flex";
}
const keyCardTemplate = `
<div class="key-card">
  <div class="progress-line" style="
    position:absolute; top:0; left:0; height:2%; width:100%;
    background:#161b22; display:block;">
    <div class="progress-fill" style="
      height:100%; width:0%; background:#58a6ff;"></div>
  </div>

  <button class="delete-btn" title="Delete this key">&times;</button>
  <div class="public-values">
    <div class="title">
      <strong>Name:</strong>
      <span class="editable-title" data-key-id="" contenteditable="true" spellcheck="false"></span>
    </div>
    <div class="otp">
      <strong>OTP:</strong>
      <span class="otp-value" style="cursor:pointer;">N/A</span>
    </div>
    <div class="status-wrapper">
      <div class="status-container">
        <strong>Status:</strong>
        <span class="status" data-key-id="">Unknown</span>
      </div>
    </div>
  </div>
</div>
`;

function createKeyCard(keyObj) {
    const template = document.createElement("template");
    template.innerHTML = keyCardTemplate.trim();
    const card = template.content.firstElementChild.cloneNode(true);
    card.id = "key-" + keyObj.id;

    const delBtn = card.querySelector(".delete-btn");
    delBtn.onclick = () => deleteKey(keyObj);

    const editableTitle = card.querySelector(".editable-title");
    editableTitle.textContent = keyObj.accountName || keyObj.title || "Unknown";
    editableTitle.dataset.keyId = keyObj.id;
    editableTitle.addEventListener("blur", function() {
        const key = keys.find(keyObj => keyObj.id === this.dataset.keyId);
        if (key) {
            const newTitle = this.textContent.trim();
            if (newTitle && newTitle !== (key.accountName || key.title)) {
                key.accountName = newTitle;
                saveKeys();
                this.textContent = newTitle;
                if (document.getElementById("managesecretKeysModal").style.display !== "none") {
                    rendersecretKeysTable();
                }
            }
        }
    });
    editableTitle.addEventListener("keydown", function(e) {
        if (e.key === "Enter") {
            e.preventDefault();
            this.blur();
        }
    });

    const otpSpan = card.querySelector(".otp-value");
    otpSpan.id = "otp-" + keyObj.id;
    otpSpan.addEventListener("click", function() {
        if (/^\d{6}$/.test(this.textContent)) {
            navigator.clipboard.writeText(this.textContent).then(() => alert("OTP copied!")).catch(e => alert("Copy failed: " + e.message));
        }
    });

    const statusSpan = card.querySelector(".status");
    statusSpan.id = "status-" + keyObj.id;
    statusSpan.dataset.keyId = keyObj.id;
    statusSpan.addEventListener("click", async function() {
        const keyId = this.dataset.keyId;
        const key = keys.find(keyObj => keyObj.id === keyId);
        if (!key) return;
        const mk = getMatchingMasterKey(key);
        if (!mk) return;
        try {
            const decryptedSecret = await decryptText(key.encryptedKey, mk.password);
            await navigator.clipboard.writeText(decryptedSecret);
            alert("Secret copied to clipboard!");
        } catch (e) {
            alert("Copy failed: " + e.message);
        }
    });

    const progressFill = card.querySelector(".progress-fill");
    progressFill.id = "progress-" + keyObj.id;
    const period = keyObj.period || 30;
    progressFill.dataset.period = period;

    return card;
}

function renderKeys() {
	const container = document.getElementById("keysContainer");
	container.innerHTML = "";
	keys.forEach((keyObj) => {
		const card = createKeyCard(keyObj);
		container.appendChild(card);
	});
}

function appendKeyCard(keyObj) {
	const container = document.getElementById("keysContainer");
	const keyCard = createKeyCard(keyObj);
	container.appendChild(keyCard);
}

function attachEditableTitleListenerToCard(cardElement) {
	const titleElem = cardElement.querySelector(".editable-title");
	if (!titleElem) return;
	titleElem.addEventListener("blur", function() {
		const keyId = this.getAttribute("data-key-id");
		const keyObj = keys.find((keyObj) => keyObj.id === keyId);
		if (keyObj) {
			const newTitle = this.textContent.trim();
			if (newTitle && newTitle !== keyObj.title) {
				keyObj.title = newTitle;
				saveKeys();
				if (document.getElementById("managesecretKeysModal").style.display !== "none") {
					rendersecretKeysTable();
				}
			}
		}
	});
	titleElem.addEventListener("keydown", function(e) {
		if (e.key === "Enter") {
			e.preventDefault();
			this.blur();
		}
	});
}

function openModal(modalId, updateFunction) {
	if (updateFunction) {
		updateFunction();
	}
	document.getElementById(modalId).style.display = "flex";
}

function closeModal(modalId) {
	document.getElementById(modalId).style.display = "none";
}

async function openManageMasterModal() {
	openModal("manageMasterModal", () => {
		renderMasterKeysTable();
		updateMasterEncryptionControls();
	});
}

async function openManagesecretKeysModal() {
	openModal("managesecretKeysModal", async () => {
		await updateDecryptionForKeys();
		rendersecretKeysTable();
	});
}

function renderSettings() {
	const container = document.getElementById('settingsContainer');
	container.innerHTML = '';
	Object.entries(settings).forEach(([key, def]) => {
		const item = document.createElement('div');
		item.className = 'setting-item';
		item.style.display = 'flex';
		item.style.alignItems = 'center';
		item.style.justifyContent = 'space-between';
		item.style.marginBottom = '1em';
		const label = document.createElement('label');
		label.textContent = def.label;
		let input;
		if (def.type === 'checkbox') {
			input = document.createElement('input');
			input.type = 'checkbox';
			input.checked = config.get(key) ?? def.default;
			input.addEventListener('change', async () => {
				const value = input.checked;
				if (def.onChange) {
					const res = await def.onChange(value, input);
					if (res === false) {
						input.checked = config.get(key) ?? def.default;
						return;
					}
				}
				config.set(key, value);
				if (def.afterChange) {
					await def.afterChange(value, input);
				}
			});
			const switchLabel = document.createElement('label');
			switchLabel.className = 'switch';
			const span = document.createElement('span');
			span.className = 'slider round';
			switchLabel.appendChild(input);
			switchLabel.appendChild(span);
			item.appendChild(label);
			item.appendChild(switchLabel);
		} else {
			input = document.createElement('input');
			input.type = def.type;
			input.value = config.get(key) ?? def.default;
			input.addEventListener('change', async () => {
				let value;
				if (def.type === 'number') value = Number(input.value);
				else value = input.value;
				if (def.onChange) {
					const res = await def.onChange(value, input);
					if (res === false) {
						input.value = config.get(key) ?? def.default;
						return;
					}
				}
				config.set(key, value);
				if (def.afterChange) {
					await def.afterChange(value, input);
				}
			});
			item.appendChild(label);
			item.appendChild(input);
		}
		container.appendChild(item);
	});
}

function openSettingsModal() {
	renderSettings();
	document.getElementById("settingsModal").style.display = "flex";
}

function renderMasterKeysTable() {
	const tbody = document.querySelector("#masterKeysTable tbody");
	tbody.innerHTML = "";
	masterKeys.forEach((mk) => {
		const usageCount = keys.filter(
			(keyObj) => keyObj.masterKeyHash === mk.hash).length;
		const tr = document.createElement("tr");
		const tdMasterKey = document.createElement("td");
		tdMasterKey.className = "master-key-cell";
		tdMasterKey.textContent = masterKeysRevealed ? mk.password : "Click to copy key";
		tdMasterKey.addEventListener("click", async function() {
			try {
				await navigator.clipboard.writeText(mk.password);
				alert("Master key copied to clipboard!");
			} catch (e) {
				alert("Copy failed: " + e.message);
			}
		});
		tr.appendChild(tdMasterKey);
		const hashToDisplay = window.innerWidth < 768 ? mk.hash.slice(0, 15) + "..." : mk.hash;
		const tdHash = document.createElement("td");
		tdHash.textContent = hashToDisplay;
		tr.appendChild(tdHash);
		const tdUsage = document.createElement("td");
		tdUsage.textContent = usageCount;
		tr.appendChild(tdUsage);
		const tdActions = document.createElement("td");
		const delBtn = document.createElement("button");
		delBtn.textContent = "Delete";
		delBtn.onclick = function() {
			if (confirm("Delete this master key?")) {
				masterKeys = masterKeys.filter((key) => key.hash !== mk.hash);
				saveMasterKeys();
				tr.remove();
				updateAffectedKeys(mk.hash);
			}
		};
		tdActions.appendChild(delBtn);
		tr.appendChild(tdActions);
		tbody.appendChild(tr);
	});
}

function updateAffectedKeys(deletedHash) {
	keys.forEach((keyObj) => {
		if (keyObj.masterKeyHash === deletedHash) {
			keyObj.decryptedSecret = null;
			const statusElement = document.getElementById(`status-${keyObj.id}`);
			if (statusElement) {
				statusElement.textContent = "Encrypted";
				statusElement.classList.add("status-encrypted");
				statusElement.classList.remove("status-decrypted");
			}
		}
	});
}

function rendersecretKeysTable() {
    const table = document.querySelector("#secretKeysTable");
    const tbody = table.querySelector("tbody");
    tbody.innerHTML = "";

    const thead = table.querySelector("thead");
    thead.innerHTML = "";
    if (keys.length > 0) {
        const headerRow = document.createElement("tr");
        Object.keys(keys[0]).forEach(key => {
            const th = document.createElement("th");
            th.textContent = key;
            headerRow.appendChild(th);
        });
        const thActions = document.createElement("th");
        thActions.textContent = "Actions";
        headerRow.appendChild(thActions);
        thead.appendChild(headerRow);
    }

    keys.forEach(keyObj => {
        const tr = document.createElement("tr");

        for (const [key, value] of Object.entries(keyObj)) {
            const td = document.createElement("td");
            let displayValue = value;

            if (key === "id" || key === "masterKeyHash") {
                displayValue = String(value).slice(0, 8) + "...";
            }

            if (key === "encryptedKey") {
                displayValue = "Click to copy";
            }

            td.textContent = displayValue;
            td.addEventListener("click", async function() {
                if (key === "encryptedKey") {
                    const mk = getMatchingMasterKey(keyObj);
                    if (!mk) {
                        alert("Master key not available.");
                        return;
                    }
                    try {
                        const decryptedSecret = await decryptText(keyObj.encryptedKey, mk.password);
                        await navigator.clipboard.writeText(decryptedSecret);
                        alert("Secret copied to clipboard!");
                    } catch (e) {
                        alert("Decryption failed: " + e.message);
                    }
                } else {
                    await navigator.clipboard.writeText(String(value));
                    alert("Value copied to clipboard!");
                }
            });

            tr.appendChild(td);
        }

        const tdActions = document.createElement("td");
        const delBtn = document.createElement("button");
        delBtn.textContent = "Delete";
        delBtn.onclick = () => deleteKey(keyObj);
        tdActions.appendChild(delBtn);
        tr.appendChild(tdActions);

        tbody.appendChild(tr);
    });
}

// ================================
// OTP Functions
// ================================

function getMatchingMasterKey(keyObj) {
    return masterKeys.find(mk => mk.hash === keyObj.masterKeyHash);
}

async function updateKeyCard(keyObj) {
    const otpSpan = document.getElementById("otp-" + keyObj.id);
    const statusSpan = document.getElementById("status-" + keyObj.id);
    const titleSpan = document.querySelector(`.editable-title[data-key-id="${keyObj.id}"]`);

    if (titleSpan) titleSpan.textContent = keyObj.accountName;

    const mk = getMatchingMasterKey(keyObj);

    if (!mk) {
        otpSpan.textContent = "N/A";
        statusSpan.textContent = "Encrypted";
        statusSpan.className = "status status-encrypted";
        return;
    }

    try {
        const otp = await generateOTP({
            ...keyObj,
            secret: await decryptText(keyObj.encryptedKey, mk.password)
        });
        otpSpan.textContent = otp;
        statusSpan.textContent = "Decrypted";
        statusSpan.className = "status status-decrypted";
    } catch (err) {
        otpSpan.textContent = "N/A";
        statusSpan.textContent = "Decryption error";
        statusSpan.className = "status status-failed";
        console.error(`Error decrypting keyObj id=${keyObj.id}:`, err);
    }
}

async function updateAllKeyCards() {
	keys.forEach((keyObj) => updateKeyCard(keyObj));
}

function updateDecryptionForKeys() {
    if (!masterKeys.length) {
        keys.forEach(keyObj => keyObj.status = "encrypted");
        return;
    }

    keys.forEach(keyObj => {
        const mk = getMatchingMasterKey(keyObj);
        keyObj.status = mk && keyObj.masterKeyHash === mk.hash ? "decrypted" : mk ? "failed" : "encrypted";
    });
}

function decryptKey(keyObj, mk) {
    return keyObj.masterKeyHash === mk.hash ? "decrypted" : "encrypted";
}

// ================================
// Export and Import
// ================================

function prepareKey(keyObj, options = {}) {
    const KeyObj = { 
        id: keyObj.id,
        accountName: keyObj.accountName || keyObj.title || "Unknown",
        encryptedKey: keyObj.encryptedKey,
        masterKeyHash: keyObj.masterKeyHash || keyObj.encryptionHash,
        issuer: keyObj.issuer || "Unknown",
        digits: keyObj.digits || 6,
        period: keyObj.period || 30,
        algorithm: keyObj.algorithm || "SHA1"
    };

    if (options.shortImport) {
        if (KeyObj.digits === 6) delete KeyObj.digits;
        if (KeyObj.period === 30) delete KeyObj.period;
        if (KeyObj.algorithm === "SHA1") delete KeyObj.algorithm;
        if (KeyObj.issuer === "Unknown") delete KeyObj.issuer;
    }

    return KeyObj;
}

async function exportData(toFile = false, shortImport = false) {
    const password = await prompt("Enter password for exporting data (use 'raw' for no encryption):", 1);
    if (!password) return;

    try {
        const output = await processExport(keys, masterKeys, password, shortImport);
        
        if (toFile) {
            const now = new Date();
            const timestamp = now.toISOString().replace(/[:.]/g, "-");
            const filename = `${timestamp}.keystore`;
            const blob = new Blob([output], { type: "text/plain" });
            const url = URL.createObjectURL(blob);
            const a = document.createElement("a");
            a.href = url;
            a.download = filename;
            a.click();
            URL.revokeObjectURL(url);
            alert("Data exported to file: " + filename);
        } else {
            try {
                await navigator.clipboard.writeText(output);
                alert("Data successfully exported and copied to clipboard!");
            } catch {
                showCopyModal(output);
            }
        }
    } catch (e) {
        alert("Error exporting data: " + e.message);
    }
}

async function processExport(keysList, masterKeysList, password, shortImport = false) {
    const keysForExport = keysList.map(k => prepareKey(k, { shortImport }));
    const combined = JSON.stringify({ keys: keysForExport, masterKeys: masterKeysList });

    if (password === "raw") return combined;

    return await encryptText(combined, password);
}

async function importData(fromFile = false) {
    if (fromFile) {
        const fileInput = document.createElement("input");
        fileInput.type = "file";
        fileInput.accept = ".keystore";
        fileInput.onchange = async (event) => {
            const file = event.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = async () => {
                await processImport(reader.result);
            };
            reader.readAsText(file);
        };
        fileInput.click();
    } else {
        const input = await prompt("Paste the string to import data:");
        if (input) await processImport(input.trim());
    }
}

async function processImport(input) {
    let combined;

    try {
        combined = JSON.parse(input);
        if (!combined.keys) {
            const password = await prompt("Enter password for encrypted data:", 1);
            if (!password) return;
            combined = JSON.parse(await decryptText(input, password));
        }
    } catch (e) {
        console.error("Failed to parse/import data:", e);
        alert("Failed to import data: " + e.message);
        return;
    }

    try {
        let newKeys = combined.keys ? combined.keys.map(k => prepareKey(k, { shortImport: false })) : [];

        newKeys.forEach(newKey => {
            const existingKey = keys.find(k => k.id === newKey.id);
            if (existingKey) {
                if (existingKey.accountName !== newKey.accountName) {
                    existingKey.accountName = newKey.accountName;
                    updateKeyCard(existingKey).catch(err => console.error(`Error updating key card id=${existingKey.id}:`, err));
                }
            } else {
                keys.push(newKey);
                appendKeyCard(newKey);
            }
        });

        await saveKeys();

        if (combined.masterKeys) {
            let addedAnyMasterKey = false;

            for (const mk of combined.masterKeys) {
                if (!masterKeys.some(existing => existing.hash === mk.hash)) {
                    masterKeys.push(mk);
                    addedAnyMasterKey = true;
                }
            }

            if (addedAnyMasterKey) {
                await saveMasterKeys();

                keys.forEach(keyObj => {
                    const mkMatch = masterKeys.some(mk => mk.hash === keyObj.masterKeyHash);
                    if (mkMatch) {
                        updateKeyCard(keyObj).catch(err => console.error(`Error updating key card id=${keyObj.id}:`, err));
                    }
                });
            }
        }
    } catch (e) {
        console.error("Error processing imported data:", e);
        alert("Error processing imported data: " + e.message);
    }
}

// ================================
// Init and Event Listeners
// ================================

function initEventListeners() {
	document.getElementById("copyButton").addEventListener("click", async function() {
		const textarea = document.getElementById("copyTextArea");
		try {
			await navigator.clipboard.writeText(textarea.value);
			alert("Copied to clipboard!");
		} catch (e) {
			alert("Copy failed: " + e.message);
		}
		document.getElementById("copyModal").style.display = "none";
	});
	document.getElementById("clearStorageBtn").addEventListener("click", function() {
		if (!confirm("Are you sure you want to permanently clear all data? This action cannot be undone.")) {
			return;
		}
		localStorage.removeItem("authKeys");
		localStorage.removeItem("masterKeys");
		localStorage.removeItem("masterKeysEncKeyHash");
		history.replaceState(null, "", window.location.pathname);
		sessionEncKey = null;
		loadKeys();
		loadMasterKeys();
		renderKeys();
		updateEncButton();
	});
	window.addEventListener("click", function(event) {
		const modals = [{
			element: document.getElementById("manageMasterModal"),
			closeFunction: () => closeModal("manageMasterModal")
		}, {
			element: document.getElementById("managesecretKeysModal"),
			closeFunction: () => closeModal("managesecretKeysModal")
		}, {
			element: document.getElementById("settingsModal"),
			closeFunction: () => closeModal("settingsModal")
		}, {
			element: document.getElementById("addKeyUIModal"),
			closeFunction: () => closeModal("addKeyUIModal")
		}, {
			element: document.getElementById("qrScannerModal"),
			closeFunction: () => closeModal("qrScannerModal")
		}];
		modals.forEach(modal => {
			if (event.target === modal.element) {
				modal.closeFunction();
			}
		});
	});
	document.getElementById("toggleRevealMasterKeysBtn")?.addEventListener("click", function() {
		masterKeysRevealed = !masterKeysRevealed;
		this.textContent = masterKeysRevealed ? "Hide master keys" : "Reveal master keys";
		renderMasterKeysTable();
	});
}

function startCameraScan() {
	closeModal('addKeyUIModal');
	openModal('qrScannerModal');
	startCamera();
}

function handleFileSelection(event) {
	const files = Array.from(event.target.files);
	files.forEach(file => {
		const reader = new FileReader();
		const img = new Image();
		reader.onload = function(e) {
			img.src = e.target.result;
			img.onload = function() {
				parseQRCode(img);
			};
		};
		reader.readAsDataURL(file);
	});
}

function startCamera() {
	const video = document.getElementById('video');
	navigator.mediaDevices.getUserMedia({
		video: {
			facingMode: "environment"
		}
	}).then(stream => {
		video.srcObject = stream;
		video.setAttribute("playsinline", true);
		video.play();
		requestAnimationFrame(scanQRCode);
	}).catch(err => console.warn(err));
}

function stopCamera() {
	const video = document.getElementById('video');
	if (video.srcObject) {
		video.srcObject.getTracks().forEach(track => track.stop());
		video.srcObject = null;
	}
}

function scanQRCode() {
	const video = document.getElementById('video');
	const canvas = document.getElementById('canvas');
	canvas.willReadFrequently = true;
	const ctx = canvas.getContext('2d');
	const modal = document.getElementById('qrScannerModal');
	if (modal.style.display !== "flex") {
		stopCamera();
		return;
	}
	if (video.readyState === video.HAVE_ENOUGH_DATA) {
		canvas.height = video.videoHeight;
		canvas.width = video.videoWidth;
		ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
		const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
		const qrCode = jsQR(imageData.data, canvas.width, canvas.height);
		if (qrCode) {
			parseQRCodeFromText(qrCode.data);
			closeModal("qrScannerModal");
		}
	}
	requestAnimationFrame(scanQRCode);
}

function parseQRCode(image) {
	const canvas = document.getElementById('canvas');
	canvas.willReadFrequently = true;
	const ctx = canvas.getContext('2d');
	canvas.width = image.width;
	canvas.height = image.height;
	ctx.drawImage(image, 0, 0);
	const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
	const qrCode = jsQR(imageData.data, canvas.width, canvas.height);
	if (qrCode) {
		parseQRCodeFromText(qrCode.data);
	} else {
		alert('QR code not found.');
	}
}

function parseQRCodeFromText(qrText, masterKey) {
    console.log("Parsing QR code:", qrText);

    if (qrText.startsWith('otpauth-migration://')) {
        const urlObj = new URL(qrText);
        let dataParam = urlObj.searchParams.get('data');
        if (dataParam) {
            dataParam = decodeURIComponent(dataParam);
            console.log("Detected otpauth-migration, data parameter decoded.");
            parseOtpauthMigration(dataParam, masterKey);
        }
        return;
    }

    const prefix = 'otpauth://totp/';
    if (!qrText.startsWith(prefix)) {
        console.warn('QR text does not start with expected prefix. Full text:', qrText);
        alert('Invalid QR code format.');
        return;
    }

    const decodedQRText = decodeURIComponent(qrText);
    const remainingText = decodedQRText.slice(prefix.length);

    const [path, queryString] = remainingText.split('?');
    if (!queryString) {
        console.warn('No query string found in QR code. Full remaining text:', remainingText);
        alert('Invalid QR code format: Missing query parameters.');
        return;
    }

    let accountName = path.replace(':', ': ');
    const urlParams = new URLSearchParams(queryString);

    const keyValue = urlParams.get('secret');
    if (!keyValue) {
        console.warn('Secret not found in QR code query string:', queryString);
        alert('Invalid QR code: secret missing.');
        return;
    }

    const issuer = urlParams.get('issuer') || '';
    const digits = parseInt(urlParams.get('digits')) || 6;
    const period = parseInt(urlParams.get('period')) || 30;
    const algorithm = urlParams.get('algorithm') || 'SHA1';

    if (issuer && !accountName.includes(issuer)) {
        accountName = `${issuer}: ${accountName}`;
    }

    addKeyUI(accountName, keyValue, { issuer, digits, period, algorithm });
}

function parseOtpauthMigration(dataParam, masterKey) {
    try {
        if (!dataParam) throw new Error("data parameter is empty");
        const bytes = base64ToUint8Array(dataParam);
        const root = protobuf.parse(protoDefinition).root;
        const MigrationPayload = root.lookupType("migration.MigrationPayload");
        const payload = MigrationPayload.decode(bytes);
        const object = MigrationPayload.toObject(payload, { longs: String, enums: String, bytes: String, defaults: true });

        object.otpParameters.forEach(param => {
            const accountNameOriginal = param.name || '';
            const issuer = param.issuer || '';
            const accountName = issuer && !accountNameOriginal.includes(issuer)
                ? `${issuer}: ${accountNameOriginal}`
                : accountNameOriginal;

            const base32Secret = base64ToBase32(param.secret);

            addKeyUI(accountName, base32Secret, {
                issuer,
                digits: 6, // Google Authenticator export sets "digits" to random shit like 2
                period: param.period || 30,
                algorithm: param.algorithm || 'SHA1'
            });
        });
    } catch (error) {
        console.error("Error parsing otpauth-migration:", error.message);
    }
}

async function addKey(accountName, keyValue, masterKey, options = {}) {
    const encrypted = await encryptText(keyValue, masterKey.password);
    const id = await sha256(accountName + keyValue);

    let keyObj = {
        id: id,
        accountName: accountName,
        encryptedKey: encrypted,
        masterKeyHash: masterKey.hash,
        issuer: options.issuer,
        digits: options.digits,
        period: options.period,
        algorithm: options.algorithm
    };

    keyObj = prepareKey(keyObj);

    if (!keys.find(k => k.id === id)) keys.push(keyObj);
    saveKeys();
    return keyObj;
}

async function addKeyUI(accountName = null, keyValue = null, options = {}) {
  if (!accountName) {
    accountName = await prompt("Enter key name:");
    if (!accountName) return;
  }
  if (!keyValue) {
    keyValue = await prompt("Enter key value (secret):", 1);
    if (!keyValue) return;
  }

  const selectedMasterKey = await chooseMasterKey();
  if (!selectedMasterKey) return;

  try {
    const id = await sha256(accountName + keyValue);

    if (keys.find(k => k.id === id)) {
      alert(`Key ${accountName} already imported!`);
      return;
    }

    const keyObj = await addKey(accountName, keyValue, selectedMasterKey, options);
    appendKeyCard(keyObj);
    updateKeyCard(keyObj);
    closeModal('addKeyUIModal');
  } catch (e) {
    alert("Error encrypting key: " + e.message);
  }
}

async function chooseMasterKey() {
	if (masterKeys.length === 0) {
		await addMasterKey();
	}
	if (masterKeys.length === 1) {
		return masterKeys[0];
	} else {
		while (true) {
			const options = masterKeys.map(
				(mk, idx) => (idx + 1) + ": " + mk.hash.substring(0, 6) + "..." + " (" + mk.password.substring(0, 4) + "...)").join("\n");
			const choice = await prompt("Choose a master key for encryption:\n0. Add new master key\n" + options);
			const index = parseInt(choice) - 1;
			if (index >= 0 && index < masterKeys.length) {
				return masterKeys[index];
			} else if (index === masterKeys.length) {
				await addMasterKey();
				return await chooseMasterKey();
			}
		}
	}
}

async function addMasterKey() {
    const input = await prompt("Enter master key:", 1);
    if (!input) return;

    const hash = await sha256(input);
    if (masterKeys.some(mk => mk.hash === hash)) {
        alert("Master key already added");
        return;
    }

    masterKeys.push({ password: input, hash: hash });
    await saveMasterKeys();

    keys.forEach(keyObj => {
        if (keyObj.masterKeyHash === hash) {
            updateKeyCard(keyObj);
        }
    });

    updateEncButton();
    if (document.getElementById("manageMasterModal").style.display !== "none") {
        renderMasterKeysTable();
    }
}

function startOTPUpdater() {
    function update() {
        const now = Date.now();

        document.querySelectorAll(".key-card").forEach(card => {
            const cardId = card.id.replace(/^key-/, "");
            const keyObj = keys.find(k => k.id === cardId);
            if (!keyObj) return;

            const progressEl = card.querySelector(".progress-fill");
            const periodSec = progressEl ? parseFloat(progressEl.dataset.period) || 30 : 30;
            const periodMs = periodSec * 1000;

            const timeStep = Math.floor(now / periodMs);
            if (parseInt(card.dataset.lastStep) !== timeStep) {
                updateKeyCard(keyObj);
                card.dataset.lastStep = timeStep;
            }

            if (progressEl) {
                const elapsed = (now % periodMs) / periodMs;
                progressEl.style.width = (elapsed * 100) + "%";
            }
        });

        requestAnimationFrame(update);
    }

    update();
}

async function init() {
	loadKeys();
	await loadMasterKeys();
	renderKeys();
	startOTPUpdater();
	initEventListeners();
}
document.addEventListener("DOMContentLoaded", init);

    </script>
  </body>
</html>